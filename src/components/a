import React, { useRef, useEffect, useState } from "react";
import * as ROS2D from "ros2d";
import * as ROSLIB from "roslib";
import createjs from "createjs-module";
import goal from "../scripts/goal.png";
import robot from "../scripts/robot.png";
import ToggleButton from "react-bootstrap/ToggleButton";
import ToggleButtonGroup from "react-bootstrap/ToggleButtonGroup";
import charging_station from "../scripts/charging_station.png";
import getYawFromQuat from "../scripts/getY";
import { IoIosRefresh } from "react-icons/io";
import { BsZoomIn } from "react-icons/bs";
import { FaExpandArrowsAlt } from "react-icons/fa";
import { GiStoneWall } from "react-icons/gi";
import { BiShapePolygon } from "react-icons/bi";
import { RiDeleteBinLine } from "react-icons/ri";
import { GiPositionMarker } from "react-icons/gi";
import { Row, Col, Container } from "react-bootstrap"; // import feature from react bootstrap

const Map = (props) => {
  var gridClient;
  var robot_image;
  var viewer;
  var canvas;
  var context;
  var trace_shape;
  var global_path_image;
  var local_path_image;
  var goal_image;
  // let footprintpolygon = [];
  var footprint = null;
  var charging_station_param = null;
  var cahrging_station_image1 = null;
  var cahrging_station_image2 = null;
  const map = useRef(null);
  const ros = props.ros;
  const [points, setpoints] = useState(null);
  var panView;
  var zoomView;

  useEffect(() => {
    viewMap();
    console.log(viewer);
    map.current.style.pointerEvents = "null";
    map.current.children[0].id = "canvas";
    canvas = document.getElementById("canvas");
    context = canvas.getContext("2d");
    context.fillStyle = "#FF";
    // context.fillRect(80, 60, 140, 30);

    var footprintParam = new ROSLIB.Param({
      ros: ros,
      name: "/move_base_node/footprint",
    });
    footprintParam.get((footprintpoints) => {
      footprint = footprintpoints;
      // console.log(footprint);
      // drawFootprint();
    });
  }, []);

  function charging_stations1() {
    cahrging_station_image1.x = charging_station_param.position.x;
    cahrging_station_image1.y = -charging_station_param.position.y;
    cahrging_station_image1.rotation = (-getYawFromQuat(
      charging_station_param.orientation
    )).toFixed(2);
  }

  function charging_stations2() {
    cahrging_station_image2.x = charging_station_param.position.x;
    cahrging_station_image2.y = -charging_station_param.position.y;
    cahrging_station_image2.rotation = (-getYawFromQuat(
      charging_station_param.orientation
    )).toFixed(2);
    // var zoomView = new ROS2D.ZoomView({
    //   rootObject: viewer.scene,
    // });
    // // Add panning to the viewer.
    // var panView = new ROS2D.PanView({
    //   rootObject: viewer.scene,
    // });
    gridClient.on("change", function () {
      viewer.scaleToDimensions(
        gridClient.currentGrid.width,
        gridClient.currentGrid.height
      );
      viewer.shift(
        gridClient.currentGrid.pose.position.x,
        gridClient.currentGrid.pose.position.y
      );
    });
  }

  // function draw_polygons(polygon_zone) {
  //   for (let i = 0; i < polygon_zone.length; i++) {
  //     var pointColor = null;
  //     var x = polygon_zone[i].zone_type;
  //     switch (x) {
  //       case 1:
  //         pointColor = createjs.Graphics.getRGB(205, 155, 190); // BLUE
  //         break;
  //       case 2:
  //         pointColor = createjs.Graphics.getRGB(174, 223, 249); // foshia
  //         break;
  //       default: // BLACK
  //         pointColor = createjs.Graphics.getRGB(0, 0, 0, 1);
  //         break;
  //     }
  //     var polygon_iterator = new ROS2D.PolygonMarker({
  //       pointSize: 0.000001,
  //       lineSize: 0.06,
  //       pointColor: pointColor,
  //       lineColor: createjs.Graphics.getRGB(121, 65, 181),
  //     });
  //     viewer.scene.addChild(polygon_iterator);
  //     for (let j = 0; j < polygon_zone[i].polygon.points.length; j++) {
  //       polygon_iterator.addPoint(polygon_zone[i].polygon.points[j]);
  //     }
  //   }
  //   console.log(polygon_iterator);
  //   // drawFootprint();
  // }

  // to move the robot b the data that came from ros side
  //call back function
  function subscribers() {
    var position = new ROSLIB.Topic({
      ros: ros,
      name: "/robot_pose",
      messageType: "geometry_msgs/Pose",
    }).subscribe((message) => {
      robot_image.x = message.position.x.toFixed(2);
      robot_image.y = -message.position.y.toFixed(2);
      robot_image.rotation = (-getYawFromQuat(message.orientation)).toFixed(2);
      trace_shape.addPose(message);
    });
    var trace_Shape = new ROSLIB.Topic({
      ros: ros,
      name: "/move_base/feedback",
      messageType: "/move_base_msgs/MoveBaseActionFeedback",
    });
    trace_Shape.subscribe(function (message) {
      trace_shape.addPose(message.feedback.base_position.pose);
      // trace_Shape.addPose({ position });
    });

  
  }

  function render_elments() {
    let polygon_zone = [];
    var zone = new ROSLIB.Topic({
      ros: ros,
      name: "/zones",
      messageType: "/mir_msgs/Zone",
    });
    zone.subscribe((message) => {
      let logic = false;
      for (let i = 0; i < polygon_zone.length; i++) {
        if (polygon_zone[i].zone_id === message.zone_id) {
          logic = true;
          break;
        }
      }
      if (!logic) {
        polygon_zone.push(message);
        // draw_polygons(polygon_zone);
      }
    });
    var ros_station_param = new ROSLIB.Param({
      ros: ros,
      name: "/station1",
    });
    ros_station_param.get((param) => {
      // console.log("station 1 : " + param.position.x);
      // console.log("station 1 : " + param.position.y);
      charging_station_param = param;
      charging_stations1();
    });
    var ros_station_param = new ROSLIB.Param({
      ros: ros,
      name: "/station2",
    });
    ros_station_param.get((param) => {
      // console.log("station 2 : " + param.position.x);
      // console.log("station 2 : " + param.position.y);
      charging_station_param = param;
      charging_stations2();
    });
    var goal_subscriber = new ROSLIB.Topic({
      ros: ros,
      name: "/move_base_simple/goal",
      messageType: "geometry_msgs/PoseStamped",
    });
    var local_path = new ROSLIB.Topic({
      ros: ros,
      name: "/move_base_node/DWBLocalPlanner/local_plan",
      messageType: "nav_msgs/Path",
    }).subscribe((message) => {
      local_path_image.setPath(message);
    });
    var global_path = new ROSLIB.Topic({
      ros: ros,
      name: "/move_base_node/DWBLocalPlanner/global_plan",
      messageType: "nav_msgs/Path",
    }).subscribe((message) => {
      global_path_image.setPath(message);
    });
    robot_image = new ROS2D.NavigationImage({
      size: 1.1,
      image: robot,
      pulse: false,
      alpha: 0.9,
    });
    robot_image.x = 10;
    robot_image.y = -10;
    global_path_image = new ROS2D.PathShape({
      strokeSize: 0.02,
      strokeColor: createjs.Graphics.getRGB(0, 150, 136),
    });
    goal_image = new ROS2D.NavigationImage({
      size: 1,
      image: goal,
      alpha: 1,
      pulse: false,
    });
    trace_shape = new ROS2D.TraceShape({
      strokeSize: 0.01,
      maxPoses: 25,
      minDist: 0.03,
      strokeColor: createjs.Graphics.getRGB(255, 0, 0),
    });
    local_path_image = new ROS2D.PathShape({
      strokeSize: 0.5,
      strokeColor: createjs.Graphics.getRGB(0, 0, 0),
    });
    cahrging_station_image1 = new ROS2D.NavigationImage({
      size: 1.4,
      image: charging_station,
      alpha: 1,
      pulse: false,
    });
    cahrging_station_image2 = new ROS2D.NavigationImage({
      size: 1.4,
      image: charging_station,
      alpha: 1,
      pulse: false,
    });
    console.log(viewer);
    // console.log("Stroke: " + trace_shape.strokeSize);
    viewer.scene.addChild(cahrging_station_image1);
    viewer.scene.addChild(cahrging_station_image2);
    viewer.scene.addChild(global_path_image);
    viewer.scene.addChild(local_path_image);
    viewer.scene.addChild(trace_shape);

    goal_subscriber.subscribe((message) => {
      var yaw = getYawFromQuat(message.pose.orientation);
      // console.log(yaw);
      goal_image.x = message.pose.position.x;
      goal_image.y = -message.pose.position.y;
      goal_image.rotation = yaw;
    });
    viewer.scene.addChild(goal_image);
    viewer.scene.addChild(robot_image);
  }

  function viewMap() {
    if (map.current.innerHTML !== "") return;

    viewer = new ROS2D.Viewer({
      divID: "map",
      width: 700,
      height: 600,
    });
    // to render the map but continuously using OccupancyGridClient from ros2d library
    gridClient = new ROS2D.OccupancyGridClient({
      ros: ros,
      rootObject: viewer.scene,
      continuous: true,
    });

    // to In order for the map to be positioned exactly the size of the section allocated to it
    gridClient.on("change", () => {
      viewer.scaleToDimensions(
        gridClient.currentGrid.width,
        gridClient.currentGrid.height,
        viewer.scaleToDimensions(
          gridClient.currentGrid.width,
          gridClient.currentGrid.height
        ),
        viewer.shift(
          gridClient.currentGrid.pose.position.x,
          gridClient.currentGrid.pose.position.y
        )
        // registerMouseHandlers()
      );

      try {
        viewer.shift(
          gridClient.currentGrid.pose.position.x,
          gridClient.currentGrid.pose.position.y
        );
      } catch (error) {
        return;
      }
    });

    //call the functions
    // add_polygon();
    subscribers();
    render_elments();
    //getfootprintfromros();
  }

  function Zomming() {
    var mouseDown = false;
    var zoomKey = false;
    var startPos = new ROSLIB.Vector3();
    var zoomView = new ROS2D.ZoomView({
      rootObject: viewer.scene,
    });
    viewer.scene.addEventListener("stagemousedown", function (event) {
      zoomKey = true;
      zoomView.startZoom(event.stageX, event.stageY);
      startPos.x = event.stageX;
      startPos.y = event.stageY;
      mouseDown = true;
    });
    viewer.scene.addEventListener("stagemousemove", function (event) {
      if (mouseDown === true) {
        if (zoomKey === true) {
          var dy = event.stageY - startPos.y;
          var zoom = 1 + (10 * Math.abs(dy)) / viewer.scene.canvas.clientHeight;
          if (dy < 0) zoom = 1 / zoom;
          zoomView.zoom(zoom);
        }
      }
    });
    viewer.scene.addEventListener("stagemouseup", function (event) {
      if (mouseDown === true) {
        if (zoomKey === true) {
          zoomKey = false;
          mouseDown = false;
        }
      }
    });
  }
  function resetMap() {
   map.current.innerHTML = "";
    viewMap();
  }
  // function drawFootprint() {
  //   var x = 10;
  //   var y = 10;
  //   //console.log(footprint);
  //   // console.log(robot_image);
  //   var point1 = { x: 0, y: 0 };
  //   var point2 = { x: 0, y: 0 };
  //   var point3 = { x: 0, y: 0 };
  //   var point4 = { x: 0, y: 0 };

  //   point1.x = x + 1;
  //   point1.y = y + 1;

  //   point2.x = x - 1;
  //   point2.y = y + 1;

  //   point3.x = x - 1;
  //   point3.y = y - 1;

  //   point4.x = x + 1;
  //   point4.y = y - 1;

  //   // footprint[0][1] = y - 1;
  //   // footprint[1][0] = x + 1;
  //   // footprint[1][1] = y + 1;
  //   // footprint[2][0] = x - 1;
  //   // footprint[2][1] = y + 1;
  //   // footprint[3][0] = x - 1;
  //   // footprint[3][1] = y - 1;
  //   //  footprint[0]=robot_image.orientation- 0.213;

  //   var points = [point1, point2, point3, point4];
  //   console.log("points:" + points);

  //   var polygon = new ROS2D.PolygonMarker({
  //     pointSize: 0.000001,
  //     lineSize: 0.06,
  //     // pointColor: pointColor,
  //     lineColor: createjs.Graphics.getRGB(121, 65, 181, 212),
  //   });
  //   viewer.scene.addChild(polygon);
  //   for (let index = 0; index < points.length; index++) {
  //     var obj = { x: points[index].x, y: points[index].y, z: 0 };
  //     // var obj = { x: points[index][0], y: points[index][1], z: 0 };
  //     console.log(obj);
  //     polygon.addPoint(obj);

  //   }
  //   // polygon.addPoint({ x: points[0][0], y: points[0][1] });
  //   // polygon.addPoint({ x: points[1][0], y: points[1][1] });
  //   // polygon.addPoint({ x: points[2][0], y: points[2][1] });
  //   // polygon.addPoint({ x: points[3][0], y: points[3][1] });
  // }
  // function drawfootprint(footprintpolygon) {
  //   var pointColor = null;

  //   for (let i = 0; i < footprintpolygon.length; i++) {
  //     var polygon_iterator = new ROS2D.PolygonMarker({
  //       pointSize: 0.000001,
  //       lineSize: 0.06,
  //       pointColor: pointColor,
  //       lineColor: createjs.Graphics.getRGB(121, 65, 181),
  //     });
  //     viewer.scene.addChild(polygon_iterator);
  //     for (let j = 0; j < footprintpolygon[i].polygon.points.length; j++) {
  //       polygon_iterator.addPoint(footprintpolygon[i].polygon.points[j]);
  //     }
  //   }
  // }
  // function tail(){
  //       var trace_shape = new ROS2D.TraceShape({
  //           pointSize: 0.000001,
  //           lineSize: 0.06,
  //           pointColor: pointColor,
  //           lineColor: createjs.Graphics.getRGB(121, 65, 181),
  //         });
  //         viewer.scene.addChild(polygon_iterator);
  //         for (let j = 0; j < polygon_zone[i].polygon.points.length; j++) {
  //           polygon_iterator.addPoint(polygon_zone[i].polygon.points[j]);
  //         }
  // }

  // function panning(){
  //   ROS2D.PanView = function(options) {
  //     options = options || {};
  //     this.rootObject = options.rootObject;

  //     // get a handle to the stage
  //     if (this.rootObject instanceof createjs.Stage) {
  //       this.stage = this.rootObject;
  //     }
  //     else {
  //       this.stage = this.rootObject.getStage();
  //     }

  //     this.startPos = new ROSLIB.Vector3();
  //   };

  //   ROS2D.PanView.prototype.startPan = function(startX, startY) {
  //     this.startPos.x = startX;
  //     this.startPos.y = startY;
  //   };

  //   ROS2D.PanView.prototype.pan = function(curX, curY) {
  //     this.stage.x += curX - this.startPos.x;
  //     this.startPos.x = curX;
  //     this.stage.y += curY - this.startPos.y;
  //     this.startPos.y = curY;
  //   };
  // }

  // function zomming(){

  // }

  function myFunction() {
    var x, y;
    x = 1;
    y = 2;
    var z;
    z = x + y;
    console.log(z);
  }
//   function add_polygon() {
//     // var zoomKey = false;
//     // var panKey = false;
//     // var startPos = new ROSLIB.Vector3(); // difene a  3d vector object
//     var clickedPolygon = false;
//     var selectedPointIndex = null;
//     var dbclick = false;
//     var pointCallBack = function (
//       type,
//       event,
//       index // create a point to draw polygon
//     ) {
//       if (type === "mousedown") {
//         if (event.nativeEvent.shiftKey === true) {
//           polygon.remPoint(index);
//         } else {
//           selectedPointIndex = index;
//         }
//       }
//       // to start draw a polygon
//       clickedPolygon = true;
//     };
//     var lineCallBack = function (
//       type,
//       event,
//       index // draw the line between the points
//     ) {
//       if (type === "mousedown") {
//         if (event.nativeEvent.ctrlKey === true) {
//           polygon.splitLine(index);
//         }
//       }
//       clickedPolygon = true;
//     };
//     // Create the polygon
//     var polygon = new ROS2D.PolygonMarker({
//       pointSize: 0.3,
//       lineSize: 0.1,
//       pointColor: createjs.Graphics.getRGB(144, 144, 144, 0.3),
//       fillColor: createjs.Graphics.getRGB(0, 0, 152, 0),
//       // lineColor: createjs.Graphics.getRGB(250, 100, 255, 1),
//       pointCallBack: pointCallBack,
//       lineCallBack: lineCallBack,
//     });
//     viewer.scene.addChild(polygon);
//     viewer.scene.mouseMoveOutside = false; // doesn't seem to work
//     // Event listeners for mouse interaction with the stage

//     viewer.scene.addEventListener("stagemousemove", function (event) {
//       if (dbclick === true) return;
//       // Move point when it's dragged
//       if (selectedPointIndex !== null) {
//         var pos = viewer.scene.globalToRos(event.stageX, event.stageY);
//         polygon.movePoint(selectedPointIndex, pos);
//         setpoints(polygon.pointContainer);
//         clickedPolygon = true;
//       }
//     });
//     viewer.scene.addEventListener("stagemouseup", function (event) {
//       // Add point when not clicked on the polygon
//       if (selectedPointIndex !== null) {
//         selectedPointIndex = null;
//       } else if (
//         viewer.scene.mouseInBounds === true &&
//         clickedPolygon === false
//       ) {
//         var pos = viewer.scene.globalToRos(event.stageX, event.stageY);
//         polygon.addPoint(pos);
//         // if(polygon.pointContainer.children.length == 1){
//         //   polygon.addPoint(pos);
//         // }
//         setpoints(polygon.pointContainer);
//       }
//       clickedPolygon = false;
//     });
//   }
  // function send_goal() {
  //   var dbclick = false;
  //   var clickedPolygon = false;
  //   var selectedPointIndex = null;
  //   var pointCallBack = function (
  //     type,
  //     event,
  //     index // create a point to draw polygon
  //   ) {
  //     if (type === "mousedown") {
  //       if (event.nativeEvent.shiftKey === true) {
  //         polygon.remPoint(index);
  //       } else {
  //         selectedPointIndex = index;
  //       }
  //     }
  //     // to start draw a polygon
  //     clickedPolygon = true;
  //   };
  //   var lineCallBack = function (
  //     type,
  //     event,
  //     index // draw the line between the points
  //   ) {
  //     clickedPolygon = true;
  //   };
  //   // Create the polygon
  //   var polygon = new ROS2D.PolygonMarker({
  //     pointSize: 0.3,
  //     lineSize: 0.1,
  //     pointColor: createjs.Graphics.getRGB(144, 144, 144, 0.3),
  //     // fillColor: createjs.Graphics.getRGB(0, 0, 152, 0),
  //     // lineColor: createjs.Graphics.getRGB(250, 100, 255, 1),
  //     pointCallBack: pointCallBack,
  //     // lineCallBack:lineCallBack,
  //   });
  //   viewer.scene.addChild(polygon);
  //   viewer.scene.mouseMoveOutside = false;
  //   viewer.scene.addEventListener("stagemouseup", function (event) {
  //     // Add point when not clicked on the polygon
  //     if (selectedPointIndex !== null) {
  //       selectedPointIndex = null;
  //     } 
  //    else if (
  //       viewer.scene.mouseInBounds === true
  //    ) {
  //       var pos = viewer.scene.globalToRos(event.stageX, event.stageY);
  //       polygon.addPoint(pos);
  //       if(polygon.pointContainer.children.length == 1){
  //         polygon.addPoint(pos);
  //       }
  //     }
  //       polygon.addPoint(pos);
  //   });

  //   viewer.scene.addEventListener("stagemousemove", function (event) {
  //     if (dbclick === true) return;
  //     // Move point when it's dragged

  //   });
  // }
 function send_goal(){
  viewer.scene.addEventListener("click", function(event) {
  var pose = viewer.scene.globalToRos(event.stageX, event.stageY);
  var goal_pub = new ROSLIB.Topic({
    ros: ros,
    name: "/move_base_simple/goal",
    messageType: "geometry_msgs/PoseStamped",
  });

  var goal = new ROSLIB.Message({
    header: {
      frame_id: "map",
    },
    pose: {
      position: {
        x: pose.x,
        y: pose.y,
        z: 0,
      },
      orientation: {
        x: 0,
        y: 0,
        z: 0,
        w: 1,
      },
    },
  });
  goal_pub.publish(goal);
});
 }
 function add_polygon() {
    var dbclick = false;
    var clickedPolygon = false;
    var selectedPointIndex = null;
    var pointCallBack = function (
      type,
      event,
      index // create a point to draw polygon
    ) {
      if (type === "mousedown") {
        if (event.nativeEvent.shiftKey === true) {
          polygon.remPoint(index);
        } else {
          selectedPointIndex = index;
        }
      }
      // to start draw a polygon
      clickedPolygon = true;
    };
    var lineCallBack = function (
      type,
      event,
      index // draw the line between the points
    ) {
      clickedPolygon = true;
    };
    // Create the polygon
    var polygon = new ROS2D.PolygonMarker({
      pointSize: 0.3,
      lineSize: 0.1,
      pointColor: createjs.Graphics.getRGB(144, 144, 144, 0.3),
      // fillColor: createjs.Graphics.getRGB(0, 0, 152, 0),
      // lineColor: createjs.Graphics.getRGB(250, 100, 255, 1),
      pointCallBack: pointCallBack,
      // lineCallBack:lineCallBack,
    });
    viewer.scene.addChild(polygon);
    viewer.scene.mouseMoveOutside = false;
    viewer.scene.addEventListener("stagemouseup", function (event) {
      // Add point when not clicked on the polygon
      if (selectedPointIndex !== null) {
        selectedPointIndex = null;
      } 
     else if (
        viewer.scene.mouseInBounds === true
     ) {
        var pos = viewer.scene.globalToRos(event.stageX, event.stageY);
        polygon.addPoint(pos);
        if(polygon.pointContainer.children.length == 1){
          polygon.addPoint(pos);
        }
      }
        polygon.addPoint(pos);

      clickedPolygon = false;
    });

    viewer.scene.addEventListener("stagemousemove", function (event) {
      if (dbclick === true) return;
      // Move point when it's dragged
      if (selectedPointIndex !== null) {
        var pos = viewer.scene.globalToRos(event.stageX, event.stageY);
        polygon.movePoint(selectedPointIndex, pos);
        setpoints(polygon.pointContainer);
        clickedPolygon = true;
      }
    });
  }

  return (
    <div>
      <Container>
        <Row>
          <Col>
            <div ref={map} id="map"></div>
          </Col>
          <Col>
            <ToggleButtonGroup
              // type="radio"
              name="options"
              defaultValue={1}
              size="lg"
              id="togglegroup"
            >
              <ToggleButton
                id="tbg-radio-1"
                value={1}
                title="Panning"
                onClick={myFunction}
              >
                <FaExpandArrowsAlt></FaExpandArrowsAlt>
              </ToggleButton>
              <ToggleButton
                id="tbg-radio-2"
                value={2}
                title="Zoom"
                onClick={Zomming}
              >
                <BsZoomIn></BsZoomIn>
              </ToggleButton>
              <ToggleButton
                id="tbg-radio-3"
                value={3}
                title="Add Polygon"
                onClick={add_polygon}
              >
                <BiShapePolygon></BiShapePolygon>
              </ToggleButton>
              <ToggleButton
                id="tbg-radio-4"
                value={4}
                title="Delete"
                // onClick={console.log("del")}
              >
                <RiDeleteBinLine></RiDeleteBinLine>
              </ToggleButton>
              <ToggleButton
                id="tbg-radio-5"
                value={5}
                title="Add Virtual Wall"
                // onClick={}
              >
                <GiStoneWall></GiStoneWall>
              </ToggleButton>
              <ToggleButton
                id="tbg-radio-6"
                value={6}
                title="Send Goal"
                onClick={send_goal
                }
              >
                <GiPositionMarker></GiPositionMarker>
              </ToggleButton>
              <ToggleButton
                id="tbg-radio-7"
                value={7}
                title="Reset Map"
                onClick={resetMap}
              >
                <IoIosRefresh></IoIosRefresh>
              </ToggleButton>
            </ToggleButtonGroup>
          </Col>
        </Row>
      </Container>
    </div>
  );
};
export default Map;
let charging_station = [];
const [number_of_stations, setnumber_of_stations] = useState(0);

for (let i = 0; i < number_of_stations.length; i++) {
  const a = number_of_stations[i];
  a.push(number_of_stations[i]);
}
var ros_station_param = new ROSLIB.Param({
  ros: ros,
  name: "number_of_stations",
});
ros_station_param.get((number_of_stations) => {
  console.log(number_of_stations);
  setnumber_of_stations(number_of_stations);
});